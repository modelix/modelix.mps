import de.itemis.mps.gradle.BuildLanguages
import de.itemis.mps.gradle.RunAntScript
import de.itemis.mps.gradle.GenerateLibrariesXml
import de.itemis.mps.gradle.TestLanguages

plugins {
    id "java"
    id 'maven-publish'
}

configurations {
    ant_lib
    mps
    mpsArtifacts
    libs
    modelServer
}

File scriptFile(String relativePath) {
    new File("$rootDir/build/$relativePath")
}

ext.artifactsDir = new File(rootDir, 'artifacts')
ext.libsDir = new File(rootDir, 'libs')
ext.mpsDir = new File(artifactsDir, 'mps')
ext.modelServerDir = new File(artifactsDir, 'model-server')

dependencies {
    ant_lib "org.apache.ant:ant-junit:1.10.1"
    mps "com.jetbrains:mps:$mpsVersion"
    mpsArtifacts "de.itemis.mps:extensions:$mpsExtensionsVersion"
    libs "org.jdom:jdom:2.0.2"
    modelServer "org.modelix:model-server-fatjar:$modelixCoreVersion"
}

task generateLibrariesXml(type: GenerateLibrariesXml) {
    description "Will read project libraries from projectlibraries.properties and generate libraries.xml in .mps directory. Libraries are loaded in mps during start."
    defaults rootProject.file('projectlibraries.properties')
    destination file('code/.mps/libraries.xml')
    overrides rootProject.file('projectlibraries.overrides.properties')
}

task resolveLibs(type: Copy) {
    doFirst {
        delete libsDirectory
    }
    from {
        configurations.libs.resolve()
    }
    into libsDirectory
}

task resolveMps(type: Copy) {
    from {
        configurations.mps.resolve().collect { zipTree(it) }
    }
    into mpsDir
}

task resolveModelServer(type: Copy) {
    dependsOn configurations.modelServer
    from {
        configurations.modelServer
    }
    into modelServerDir
    rename { String fileName ->
        "model-server-fatjar.jar"
    }
}

task resolveMpsArtifacts(type: Copy) {
    from {
        configurations.mpsArtifacts.resolve().collect { zipTree(it) }
    }
    into artifactsDir
}

task setup {
    // We resolve MPS not for the users to use it but for the distribution packaging script to be able to refer to it.
    dependsOn resolveMpsArtifacts
    dependsOn generateLibrariesXml
    description 'Set up MPS project libraries. Libraries are read in from projectlibraries.properties file.'
}

ext.defaultAntScriptArgs = [
        '-Dproject.home=' + file(rootDir).getAbsolutePath(),
        '-Dmps.home=' + mpsDir.getAbsolutePath(),
        '-Dartifacts.root=' + new File(rootDir, 'artifacts'),
        '-DmodelixVersion=' + project.version,
        '-Dant.build.javac.source=11',
        '-Dant.build.javac.target=11'
]
ext.buildScriptClasspath = project.configurations.ant_lib.fileCollection({ true })


// -------- Model Client ----------------------

configurations {
    modelApi
    modelClient
    lightModelServer
}

dependencies {
    modelApi("org.modelix:model-api:$modelixCoreVersion")
    modelClient("org.modelix:model-client:$modelixCoreVersion")
    lightModelServer("org.modelix:light-model-server:$modelixCoreVersion")
}

def artifactNameWithoutVersion(ResolvedArtifact artifact) {
    return artifact.moduleVersion.id.name + "." + artifact.extension
}

def copyJarsWithoutModelApi(Configuration conf, File libFolder) {
    // copy transitive dependencies without version in the file name
    // otherwise each new version would require a change of the MPS solution

    def jarsFromModelApi = new HashMap<String, File>()
    configurations.modelApi.resolvedConfiguration.resolvedArtifacts
            .forEach { jarsFromModelApi.put(artifactNameWithoutVersion(it), it.file) }

    libFolder.deleteDir()
    libFolder.mkdir()
    def versionsFile = file("$libFolder/versions.txt")

    def modelClientResolved = conf.resolvedConfiguration
    for (final def artifact in modelClientResolved.resolvedArtifacts) {
        def fromModelApi = jarsFromModelApi.get(artifactNameWithoutVersion(artifact))
        if (fromModelApi != null) {
            if (fromModelApi.name == artifact.file.name) {
                versionsFile.append(artifact.file.name + " (already part of org.modelix.model.api)\n")
            } else {
                versionsFile.append(artifact.file.name + " (already part of org.modelix.model.api: " + fromModelApi.name + ")\n")
            }
            continue
        }
        def sourceFile = java.nio.file.Path.of(artifact.file.absolutePath)
        def targetFile = java.nio.file.Path.of(libFolder.absolutePath).resolve(artifactNameWithoutVersion(artifact))
        java.nio.file.Files.copy(sourceFile, targetFile)
        versionsFile.append(artifact.file.name + "\n")
    }
}


task copyModelClientToMps() {
    dependsOn configurations.modelApi
    dependsOn configurations.modelClient
    doLast {
        copyJarsWithoutModelApi(configurations.modelClient, file("$projectDir/org.modelix.model.client/lib"))
    }
}

task copyLightModelServerToMps() {
    dependsOn configurations.modelApi
    dependsOn configurations.lightModelServer
    doLast {
        copyJarsWithoutModelApi(configurations.lightModelServer, file("$projectDir/org.modelix.model.server.mpsplugin/lib"))
    }
}

task copyJarsToMps() {
    dependsOn(copyModelClientToMps)
    dependsOn(copyLightModelServerToMps)
}

// -------------------------------------------

task generateMpsBuildScript(type: BuildLanguages, dependsOn: [
        resolveMps,
        resolveMpsArtifacts,
        ':ui-client:packageNpmApp',
        copyModelClientToMps,
        copyLightModelServerToMps
]) {
    scriptArgs = defaultAntScriptArgs
    scriptClasspath = buildScriptClasspath
    script new File("$rootDir/build-scripts.xml")
}

task buildMpsModules(
        type: BuildLanguages,
        dependsOn: [
                generateMpsBuildScript,
                resolveMps,
                resolveMpsArtifacts
        ]) {
    scriptArgs = defaultAntScriptArgs
    description = "Build all MPS language"
    scriptClasspath = buildScriptClasspath
    script new File("$rootDir/build/org.modelix/build.xml")
}

assemble.dependsOn(buildMpsModules)

task runMpsTests(type: TestLanguages, dependsOn: buildMpsModules) {
    scriptArgs = defaultAntScriptArgs
    scriptClasspath = buildScriptClasspath
    script new File("$rootDir/build/test.org.modelix/build-tests.xml")
}

task justBuildIntegrationTests(type: BuildLanguages, dependsOn: []) {
    scriptArgs = defaultAntScriptArgs
    scriptClasspath = buildScriptClasspath
    script new File("$rootDir/build/integrationtests.org.modelix/build-integrationtests.xml")
}

import org.apache.tools.ant.taskdefs.condition.Os

task makePrintEnvExecutable(type: Exec) {
    commandLine "chmod", "+x", new File("$rootDir/artifacts/mps/bin/mac/printenv.py").getAbsolutePath()
}

task ensurePrintEnvHasRightPermissions() {
    doLast {
        def printenv = new File("$rootDir/artifacts/mps/bin/mac/printenv.py")
        if (printenv.exists()) {
            makePrintEnvExecutable.exec()
        }    
    }
}

task setExecutionModeToIntegrationTests() {
    doLast {    
        def buildFile = new File("$rootDir/build/integrationtests.org.modelix/build-integrationtests.xml")
        def xml = new XmlParser().parse(buildFile)
        def target = xml.target.find { node -> node.@name == 'run.org.modelix.integrationtests'}
        def jvmArgs = target.runMPS.jvmargs

        def found = jvmArgs.arg.find { node -> node.@value == '-Dmodelix.executionMode=INTEGRATION_TESTS' }
        if (found == null) {
            def newJvmArg = new Node(jvmArgs.getAt(0), 'arg', [value:'-Dmodelix.executionMode=INTEGRATION_TESTS'])
            def printer = new XmlNodePrinter(buildFile.newPrintWriter())
            printer.print(xml)
        }
    }
}

task justRunIntegrationTests(type: RunAntScript, dependsOn: [resolveModelServer, ensurePrintEnvHasRightPermissions, setExecutionModeToIntegrationTests]) {
    dependsOn(":mps:resolveModelServer")
    targets = ['run.org.modelix.integrationtests']
    scriptArgs = (defaultAntScriptArgs + ['-Dmodelix.executionMode=INTEGRATION_TESTS','-Dmps.macro.modelix.executionMode=INTEGRATION_TESTS'])
    scriptClasspath = buildScriptClasspath
    script new File("$rootDir/build/integrationtests.org.modelix/build-integrationtests.xml")
}

task runIntegrationTestsWithoutRebuildingModelix(dependsOn: [justBuildIntegrationTests, justRunIntegrationTests]) {

}

task runIntegrationTests(dependsOn: [resolveModelServer, buildMpsModules, justBuildIntegrationTests, justRunIntegrationTests]) {

}

task checkMpsTestOutput(dependsOn: runMpsTests) {
    ext.testResultFile = file("$rootDir/build/test.org.modelix/TEST-jetbrains.mps.testbench.junit.suites.AntModuleTestSuite0-all.xml")
    inputs.file testResultFile
    doLast {
        def testResult = new XmlParser().parse(testResultFile)
        def failingTests = testResult.attribute("failures")
        def totalTests = testResult.attribute("tests")
        if (failingTests != "0") {
            def failures = testResult.testcase.failure
            for (failure in failures) {
                println("Failed test: " + failure.parent().@classname + " " + failure.parent().@name)
                println(failure.text())
            }
            throw new RuntimeException(failingTests + " of " + totalTests + " MPS tests are failing")
        }
    }
}

test.dependsOn(checkMpsTestOutput)


task packageMpsModelPlugin(type: Zip, dependsOn: buildMpsModules) {
    baseName 'org.modelix.model.mpsplugin'
    from "$rootDir/build/org.modelix/build/artifacts/org.modelix/plugins"
    include "org.modelix.model/**"
    include "org.modelix.common/**"
}

task packageModelixWebEditorsPlugin(type: Zip, dependsOn: buildMpsModules) {
    baseName 'org.modelix.ui'
    from "$rootDir/build/org.modelix/build/artifacts/org.modelix/plugins"
    include "org.modelix.ui/**"
}

task packageBuildScripts(type: Zip, dependsOn: buildMpsModules) {
    baseName 'org.modelix.buildscripts'
    from "$rootDir/build/org.modelix/build/artifacts/org.modelix/plugins"
}

publishing {
    publications {
        modelixMpsModelPlugin(MavenPublication) {
            groupId 'org.modelix'
            artifactId 'mps-model-plugin'
            artifact packageMpsModelPlugin
            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')
                configurations.mps.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
                configurations.mpsArtifacts.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
            }
        }
        modelixWebEditorsPlugin(MavenPublication) {
            groupId 'org.modelix'
            artifactId 'web-editors'
            artifact packageModelixWebEditorsPlugin
            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')
                configurations.mps.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
                configurations.mpsArtifacts.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
            }
        }
        modelixBuildScriptsPlugin(MavenPublication) {
            groupId 'org.modelix'
            artifactId 'build-scripts'
            artifact packageBuildScripts
            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')
                configurations.mps.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
                configurations.mpsArtifacts.resolvedConfiguration.firstLevelModuleDependencies.each {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.moduleGroup)
                    dependencyNode.appendNode('artifactId', it.moduleName)
                    dependencyNode.appendNode('version', it.moduleVersion)
                    dependencyNode.appendNode('type', it.moduleArtifacts[0].type)
                    dependencyNode.appendNode('scope', 'provided')
                }
            }
        }        
    }
}
